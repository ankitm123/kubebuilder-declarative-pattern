/*
Copyright 2018 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package golden

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"testing"

	"k8s.io/apimachinery/pkg/api/meta"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/serializer/json"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/diff"
	"k8s.io/client-go/rest"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/envtest"
	"sigs.k8s.io/controller-runtime/pkg/manager"
	"sigs.k8s.io/kubebuilder-declarative-pattern/ktest/testharness"
	"sigs.k8s.io/kubebuilder-declarative-pattern/mockkubeapiserver"
	"sigs.k8s.io/kubebuilder-declarative-pattern/pkg/patterns/addon"
	"sigs.k8s.io/kubebuilder-declarative-pattern/pkg/patterns/addon/pkg/loaders"
	"sigs.k8s.io/kubebuilder-declarative-pattern/pkg/patterns/declarative"
	"sigs.k8s.io/kubebuilder-declarative-pattern/pkg/patterns/declarative/pkg/manifest"
	"sigs.k8s.io/kustomize/kyaml/filesys"
)

// T re-exposes the parts of testing.T we're using as an interface,
// in order to play more nicely with third-party libraries (e.g. gomega).
// This helps making these testing utils compatible with the testing strategy
// generated by kubebuilder.
//
// Note that testing.T has a bunch of other things as well; these are just the
// ones currently in use in this project.
//
// See e.g. https://github.com/onsi/ginkgo/blob/master/ginkgo_t_dsl.go#L7-L17
type T interface {
	Cleanup(func())
	Errorf(format string, args ...interface{})
	Fatalf(format string, args ...interface{})
	Helper()
	Logf(format string, args ...interface{})
	TempDir() string

	Run(name string, testFunc func(t *testing.T)) bool
}

type AddToSchemeFunc func(s *runtime.Scheme) error

type ValidatorOptions struct {
	EnvtestEnvironment   *envtest.Environment
	AddToSchemeFunctions []AddToSchemeFunc
	ManagerOptions       manager.Options

	// RewriteObjects allows us to replace values in objects
	RewriteObjects func(o *unstructured.Unstructured)
}

func (opt *ValidatorOptions) WithSchema(addToSchemeFuncs ...AddToSchemeFunc) *ValidatorOptions {
	opt.AddToSchemeFunctions = append(opt.AddToSchemeFunctions, addToSchemeFuncs...)
	return opt
}

func NewValidator(t T, opt ValidatorOptions) *validator {
	v := &validator{T: t, scheme: runtime.NewScheme(), options: opt}
	for _, addToSchemeFunc := range opt.AddToSchemeFunctions {
		if err := addToSchemeFunc(v.scheme); err != nil {
			t.Fatalf("error from AddToScheme: %v", err)
		}
	}

	v.T.Helper()
	addon.Init()
	v.findChannelsPath()

	return v
}

type validator struct {
	T       T
	scheme  *runtime.Scheme
	TestDir string

	options ValidatorOptions
}

type kubeInstance struct {
	restConfig *rest.Config
	mgr        manager.Manager
	client     client.Client
}

func deepCopyEnvtestEnvironment(in *envtest.Environment) *envtest.Environment {
	out := &envtest.Environment{}
	*out = *in

	out.CRDInstallOptions.CRDs = nil
	for _, crd := range in.CRDInstallOptions.CRDs {
		out.CRDInstallOptions.CRDs = append(out.CRDInstallOptions.CRDs, crd.DeepCopy())
	}

	return out
}

func (v *kubeInstance) startKube(t T, opt ValidatorOptions) {
	useEnvtest := opt.EnvtestEnvironment != nil
	if useEnvtest {
		env := deepCopyEnvtestEnvironment(opt.EnvtestEnvironment)
		rc, err := env.Start()
		if err != nil {
			t.Fatalf("failed to start envtest kube-apiserver: %v", err)
		}
		v.restConfig = rc
		t.Cleanup(func() {
			if err := env.Stop(); err != nil {
				t.Errorf("error stopping envtest: %v", err)
			}
		})

	} else {
		k8s, err := mockkubeapiserver.NewMockKubeAPIServer(":0")
		if err != nil {
			t.Fatalf("error building mock kube-apiserver: %v", err)
		}

		addr, err := k8s.StartServing()
		if err != nil {
			t.Errorf("error starting mock kube-apiserver: %v", err)
		}
		// v.k8s = k8s

		t.Cleanup(func() {
			if err := k8s.Stop(); err != nil {
				t.Errorf("error stopping mock kube-apiserver: %v", err)
			}
		})

		v.restConfig = &rest.Config{
			Host: addr.String(),
		}
	}
}

func (v *kubeInstance) startControllerRuntime(t T, scheme *runtime.Scheme, opt ValidatorOptions) {
	ctx := context.Background()
	ctx, cancel := context.WithCancel(ctx)

	mgrOptions := opt.ManagerOptions
	mgrOptions.Scheme = scheme
	mgr, err := manager.New(v.restConfig, mgrOptions)
	if err != nil {
		t.Fatalf("error building manager: %v", err)
	}
	v.client = mgr.GetClient()
	v.mgr = mgr

	managerError := make(chan error)
	go func() {
		err := v.mgr.Start(ctx)
		if err != nil {
			t.Errorf("starting manager: %v", err)
		}
		managerError <- err
	}()

	// Wait for the manager to start
	if !v.mgr.GetCache().WaitForCacheSync(ctx) {
		t.Fatalf("error waiting for cache sync")
	}

	t.Cleanup(func() {
		// Cancel the context so the manager exits
		cancel()
		// Wait for manager to exit
		<-managerError
	})
}

// findChannelsPath will search for a channels directory, which is helpful when running under bazel
func (v *validator) findChannelsPath() {
	t := v.T
	// Remove this call from the test error stack frame, it is useless for
	// figuring out what test failed.
	t.Helper()

	if _, err := os.Stat(loaders.FlagChannel); err == nil {
		t.Logf("found channels in %v", loaders.FlagChannel)
		return
	}

	cwd, err := os.Getwd()
	if err != nil {
		t.Fatalf("error getting wd: %v", err)
	}
	t.Logf("cwd = %s", cwd)

	p, err := filepath.Abs(loaders.FlagChannel)
	if err != nil {
		t.Fatalf("error determining absolute channel path: %v", err)
	}

	// Strip the "channels" suffix
	p = filepath.Dir(p)

	// We walk "up" the directory tree, looking for a channels
	// subdirectory in each parent directory in the hierarchy of
	// the cwd.  This means we find the channels subdirectory for
	// our operator, even when we're running tests from a
	// subdirectory.
	n := 0
	for {
		n++
		if n > 100 {
			// Sanity check to prevent infinite recursion
			t.Errorf("stuck in loop looking for channels directory")
			break
		}

		c := filepath.Join(p, "channels")
		_, err := os.Stat(c)
		if os.IsNotExist(err) {
			// Expected - look to parent dir
			if p == filepath.Dir(p) {
				// We have hit the root
				t.Logf("unable to find channel directory")
				break
			} else {
				p = filepath.Dir(p)
				continue
			}
		} else if err != nil {
			t.Errorf("error finding channel directory: %v", err)
			break
		} else {
			loaders.FlagChannel = c
			t.Logf("found channels in %v", c)
			break
		}
	}
	t.Logf("flagChannel = %s", loaders.FlagChannel)
}

func (v *validator) Validate(reconcilerFactory func(mgr manager.Manager) (*declarative.Reconciler, error)) {
	ctx := context.TODO()

	t := v.T
	t.Helper()

	serializer := json.NewSerializerWithOptions(json.DefaultMetaFactory, v.scheme, v.scheme, json.SerializerOptions{Yaml: false, Pretty: false, Strict: false})
	yamlizer := json.NewSerializerWithOptions(json.DefaultMetaFactory, v.scheme, v.scheme, json.SerializerOptions{Yaml: true, Pretty: false, Strict: false})

	metadataAccessor := meta.NewAccessor()

	basedir := "testdata/golden"
	if v.TestDir != "" {
		basedir = v.TestDir
	}

	var testNames []string
	if err := filepath.WalkDir(basedir, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}
		if d.Name() == "input.yaml" {
			testName, err := filepath.Rel(basedir, filepath.Dir(path))
			if err != nil {
				t.Fatalf("getting relative path for %q: %v", path, err)
			}
			testNames = append(testNames, testName)
		}
		return nil
	}); err != nil {
		t.Fatalf("error listing tests in %q: %v", basedir, err)
	}

	runTest := func(testDir string, t T) {
		kube := &kubeInstance{}
		kube.startKube(t, v.options)
		kube.startControllerRuntime(t, v.scheme, v.options)

		objectsToCleanup := []client.Object{}
		// Check if there is a file containing side inputs for this test
		for _, name := range []string{"side_in.yaml", "dependencies.yaml"} {
			sideInputPath := filepath.Join(testDir, name)
			sideInputRead, err := os.ReadFile(sideInputPath)
			if err != nil {
				if !os.IsNotExist(err) {
					t.Errorf("Could not read side input file %s: %v", sideInputPath, err)
				}
			} else {
				objs, err := manifest.ParseObjects(ctx, string(sideInputRead))
				if err != nil {
					t.Fatalf("error parsing file %s: %v", sideInputPath, err)
				}

				for _, obj := range objs.Items {
					json, err := obj.JSON()
					if err != nil {
						t.Errorf("error converting resource to json in %s: %v", sideInputPath, err)
						continue
					}
					decoded, _, err := serializer.Decode(json, nil, nil)
					if err != nil {
						t.Errorf("error parsing resource in %s: %v", sideInputPath, err)
						continue
					}
					obj := decoded.(client.Object)
					if err := kube.client.Create(ctx, obj); err != nil {
						t.Errorf("error creating resource in %s: %v", sideInputPath, err)
					}
					t.Logf("created object %v %v/%v", obj.GetObjectKind().GroupVersionKind().Kind, obj.GetNamespace(), obj.GetName())
					objectsToCleanup = append(objectsToCleanup, obj)
				}
			}
		}

		inputPath := filepath.Join(testDir, "input.yaml")
		b, err := os.ReadFile(inputPath)
		if err != nil {
			t.Fatalf("error reading file %s: %v", inputPath, err)
		}

		objs, err := manifest.ParseObjects(ctx, string(b))
		if err != nil {
			t.Fatalf("error parsing file %s: %v", inputPath, err)
		}

		if len(objs.Items) != 1 {
			t.Fatalf("expected exactly one item in %s", inputPath)
		}

		crJSON, err := objs.Items[0].JSON()
		if err != nil {
			t.Fatalf("error converting CR to json in %s: %v", inputPath, err)
		}

		cr, _, err := serializer.Decode(crJSON, nil, nil)
		if err != nil {
			t.Fatalf("error parsing CR in %s: %v", inputPath, err)
		}

		{
			obj := cr.(client.Object)
			if err := kube.client.Create(ctx, obj); err != nil {
				t.Errorf("error creating resource in %s: %v", inputPath, err)
			}
			t.Logf("created object %v %v/%v", obj.GetObjectKind().GroupVersionKind().Kind, obj.GetNamespace(), obj.GetName())
			objectsToCleanup = append(objectsToCleanup, obj)
		}

		namespace, err := metadataAccessor.Namespace(cr)
		if err != nil {
			t.Fatalf("error getting namespace in %s: %v", inputPath, err)
		}

		name, err := metadataAccessor.Name(cr)
		if err != nil {
			t.Fatalf("error getting name in %s: %v", inputPath, err)
		}

		nsn := types.NamespacedName{Namespace: namespace, Name: name}

		r, err := reconcilerFactory(kube.mgr)
		if err != nil {
			t.Fatalf("building reconcile: %v", err)
		}

		var fs filesys.FileSystem
		if r.IsKustomizeOptionUsed() {
			fs = filesys.MakeFsInMemory()
		}
		objects, err := r.BuildDeploymentObjectsWithFs(ctx, nsn, cr.(declarative.DeclarativeObject), fs)
		if err != nil {
			t.Fatalf("error building deployment objects: %v", err)
		}

		var actualYAML string
		{
			var b bytes.Buffer

			for i, o := range objects.Items {
				if i != 0 {
					b.WriteString("---\n")
				}
				u := o.UnstructuredObject()
				if v.options.RewriteObjects != nil {
					v.options.RewriteObjects(u)
				}
				if err := yamlizer.Encode(u, &b); err != nil {
					t.Fatalf("error encoding to yaml: %v", err)
				}
			}
			actualYAML = b.String()
		}

		expectedPath := filepath.Join(testDir, "_expected.yaml")
		var expectedYAML string
		{
			b, err := os.ReadFile(expectedPath)
			if err != nil {
				if os.IsNotExist(err) && ShouldWriteGoldenOutput(t) {
					// We'll create the file below
				} else {
					t.Fatalf("error reading file %s: %v", expectedPath, err)
				}
			}
			expectedYAML = string(b)
		}

		if actualYAML != expectedYAML {
			if ShouldWriteGoldenOutput(t) {
				t.Logf("WRITE_GOLDEN_OUTPUT is set; replacing expected output in %s", expectedPath)
				if err := os.WriteFile(expectedPath, []byte(actualYAML), 0644); err != nil {
					t.Fatalf("error writing expected output to %s: %v", expectedPath, err)
				}
			} else {
				if err := diffFiles(t, expectedPath, actualYAML); err != nil {
					t.Logf("failed to run system diff, falling back to string diff: %v", err)
					t.Logf("diff: %s", diff.StringDiff(actualYAML, expectedYAML))
				}

				t.Errorf("unexpected diff between actual and expected YAML. See previous output for details.")
				t.Logf(`To regenerate the output based on this result, rerun this test with WRITE_GOLDEN_OUTPUT="true"`)
			}
		}

		for _, objectToCleanup := range objectsToCleanup {
			if err := kube.client.Delete(ctx, objectToCleanup); err != nil {
				t.Errorf("error deleting object: %v", err)
			}
		}
	}

	for _, testName := range testNames {
		t.Run(testName, func(t *testing.T) {
			runTest(filepath.Join(basedir, testName), t)
		})
	}
}

func ShouldWriteGoldenOutput(t T) bool {
	if os.Getenv("HACK_AUTOFIX_EXPECTED_OUTPUT") != "" {
		t.Logf("HACK_AUTOFIX_EXPECTED_OUTPUT is set, please switch to use WRITE_GOLDEN_OUTPUT.  This may be an test failure in future versions.")
		return true
	}
	return testharness.ShouldWriteGoldenOutput()
}

func diffFiles(t T, expectedPath, actual string) error {
	t.Helper()
	writeTmp := func(content string) (string, error) {
		tmp, err := os.CreateTemp("", "*.yaml")
		if err != nil {
			return "", err
		}
		defer func() {
			tmp.Close()
		}()
		if _, err := tmp.Write([]byte(content)); err != nil {
			return "", err
		}
		return tmp.Name(), nil
	}

	actualTmp, err := writeTmp(actual)
	if err != nil {
		return fmt.Errorf("write actual yaml to temp file failed: %w", err)
	}
	t.Logf("Wrote actual to %s", actualTmp)

	// pls to use unified diffs, kthxbai?
	cmd := exec.Command("diff", "-u", expectedPath, actualTmp)
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		return fmt.Errorf("set up stdout pipe from diff failed: %w", err)
	}

	if err := cmd.Start(); err != nil {
		return fmt.Errorf("start command failed: %w", err)
	}

	diff, err := io.ReadAll(stdout)
	if err != nil {
		return fmt.Errorf("read from diff stdout failed: %w", err)
	}

	if err := cmd.Wait(); err != nil {
		exitErr, ok := err.(*exec.ExitError)
		if !ok {
			return fmt.Errorf("wait for command to finish failed: %w", err)
		}
		t.Logf("Diff exited %s", exitErr)
	}

	expectedAbs, err := filepath.Abs(expectedPath)
	if err != nil {
		t.Logf("getting absolute path for %s failed: %s", expectedPath, err)
		expectedAbs = expectedPath
	}

	t.Logf("View diff: meld %s %s", expectedAbs, actualTmp)
	t.Logf("Diff: expected - + actual\n%s", diff)
	return nil
}
